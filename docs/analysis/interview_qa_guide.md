# FitMate 프로젝트 - 면접 Q&A 가이드

## 회원가입 시스템 관련 질문

### Q1: JWT를 선택한 이유는 무엇인가요?
**A:** 
- **확장성**: 마이크로서비스 아키텍처에서 상태가 없는(stateless) 인증이 유리
- **성능**: 서버 메모리 부담 없이 토큰 자체에 정보 포함
- **분산 환경**: 여러 서비스 간 인증 정보 공유 용이
- **보안**: Redis를 통한 토큰 검증으로 보안성 추가 확보

### Q2: 비밀번호를 BCrypt로 암호화하는 이유는?
**A:**
- **Salt 자동 생성**: 레인보우 테이블 공격 방지
- **Adaptive Hashing**: 컴퓨팅 파워 증가에 따른 난이도 조절 가능
- **Spring Security 호환**: 프레임워크와의 완벽한 통합
- **업계 표준**: 널리 검증된 안전한 해시 알고리즘

### Q3: 이메일 중복 검사를 언제 수행하나요?
**A:**
- **사전 검사**: 회원가입 요청 시 가장 먼저 수행
- **데이터베이스 제약**: UNIQUE 제약조건으로 이중 보안
- **사용자 경험**: 실시간 피드백으로 즉시 오류 알림
- **트랜잭션**: 실패 시 롤백으로 데이터 일관성 보장

### Q4: CSRF를 비활성화해도 안전한가요?
**A:**
- **JWT 특성**: 토큰 기반 인증에서는 CSRF 위험이 낮음
- **SameSite 정책**: 쿠키 정책으로 추가 보안
- **CORS 설정**: 허용된 도메인에서만 접근 가능
- **헤더 기반**: Authorization 헤더 사용으로 자동 전송 방지

## 온보딩 시스템 관련 질문

### Q5: 온보딩을 4단계로 나눈 이유는?
**A:**
- **인지 부하 최소화**: 한 번에 하나씩 집중할 수 있도록 설계
- **명확한 목적**: 각 단계마다 구체적인 정보 수집 목표
- **완료 동기**: 진행률 표시로 사용자 완주 동기 부여
- **이탈 방지**: 단계별 완성감으로 중도 포기 방지

### Q6: SMS 인증을 포함한 이유는?
**A:**
- **보안 강화**: 실제 사용자 확인 및 계정 보안
- **서비스 연동**: 운동 알림 등 핵심 기능을 위한 신뢰할 수 있는 연락처
- **사용자 검증**: 가짜 계정 생성 방지
- **국제화 준비**: 글로벌 서비스 확장 시 필수 기능

### Q7: 온보딩 데이터를 localStorage에 저장하는 이유는?
**A:**
- **서버 부하 감소**: 임시 데이터로 불필요한 API 호출 방지
- **네트워크 효율성**: 완료 시점에만 한 번에 전송
- **사용자 경험**: 페이지 새로고침 시에도 데이터 보존
- **오프라인 지원**: 네트워크 불안정 시에도 진행 가능

### Q8: 구글 캘린더 연동이 선택사항인 이유는?
**A:**
- **프라이버시 존중**: 사용자 선택권 보장
- **완료율 향상**: 필수가 아닌 선택으로 온보딩 완료율 높임
- **기능 분리**: 핵심 기능과 부가 기능의 명확한 구분
- **점진적 확장**: 나중에 추가 연동 기능 확장 가능

## 기술적 설계 질문

### Q9: 대용량 트래픽 시 예상되는 병목점은?
**A:**
- **데이터베이스 연결**: Connection Pool 최적화 필요
- **JWT 검증**: Redis 캐싱으로 성능 향상
- **이메일 중복 검사**: 데이터베이스 인덱싱으로 해결
- **SMS API**: Rate Limiting으로 과부하 방지

### Q10: 회원가입 실패 시 롤백 처리는 어떻게 하나요?
**A:**
- **@Transactional**: Spring의 트랜잭션 관리로 자동 롤백
- **사전 검증**: 이메일 중복 등 실패 요소 미리 확인
- **예외 처리**: GlobalExceptionHandler로 일관된 에러 응답
- **데이터 일관성**: 부분 저장 방지로 데이터 무결성 보장

### Q11: 마이크로서비스 아키텍처의 장점은?
**A:**
- **독립적 배포**: 각 서비스별 독립적인 개발/배포 가능
- **기술 다양성**: 서비스별 최적 기술 스택 선택
- **확장성**: 트래픽에 따른 개별 서비스 스케일링
- **장애 격리**: 한 서비스 장애가 전체에 영향 주지 않음

### Q12: Redis를 캐시로 사용하는 이유는?
**A:**
- **고성능**: 메모리 기반 데이터 저장으로 빠른 응답
- **다양한 자료구조**: String, Hash, Set 등 다양한 타입 지원
- **세션 관리**: 분산 환경에서 세션 공유 용이
- **TTL 지원**: 자동 만료로 메모리 관리 효율적

## 사용자 경험 관련 질문

### Q13: 온보딩 중 사용자가 이탈하면 어떻게 대응하나요?
**A:**
- **진행 상황 저장**: localStorage에 자동 저장
- **재개 기능**: 로그인 시 미완료 온보딩 감지 후 재개 제안
- **단계별 분석**: 각 단계별 이탈률 분석으로 문제점 파악
- **개선 방향**: A/B 테스팅으로 온보딩 플로우 최적화

### Q14: 모바일 환경에서의 고려사항은?
**A:**
- **반응형 디자인**: CSS Media Query로 화면 크기별 최적화
- **터치 인터페이스**: 버튼 크기 및 간격 모바일에 맞게 조정
- **입력 편의성**: 키보드 타입 최적화 (숫자, 이메일 등)
- **네트워크 최적화**: 최소한의 API 호출로 데이터 사용량 절약

### Q15: 접근성(Accessibility)은 어떻게 고려했나요?
**A:**
- **WAI-ARIA**: 스크린 리더 지원을 위한 적절한 레이블링
- **키보드 내비게이션**: 마우스 없이도 모든 기능 사용 가능
- **색상 대비**: WCAG 가이드라인에 따른 충분한 명도 대비
- **포커스 관리**: 명확한 포커스 표시 및 논리적 탭 순서

## 보안 관련 질문

### Q16: XSS 공격을 어떻게 방지하나요?
**A:**
- **입력 검증**: 클라이언트와 서버 양쪽에서 입력값 검증
- **출력 인코딩**: HTML, JavaScript 인코딩으로 악성 스크립트 무력화
- **CSP 헤더**: Content Security Policy로 스크립트 실행 제한
- **라이브러리 활용**: DOMPurify 등 검증된 라이브러리 사용

### Q17: SQL Injection을 어떻게 방지하나요?
**A:**
- **Prepared Statement**: JPA/Hibernate의 파라미터 바인딩 사용
- **입력 검증**: 특수문자 및 SQL 키워드 필터링
- **최소 권한 원칙**: 데이터베이스 사용자 권한 최소화
- **ORM 활용**: Spring Data JPA로 안전한 쿼리 자동 생성

### Q18: 개인정보 보호는 어떻게 처리하나요?
**A:**
- **최소 수집**: 서비스에 꼭 필요한 정보만 수집
- **암호화 저장**: 민감한 정보는 암호화하여 데이터베이스 저장
- **접근 제어**: 개인정보 접근 권한 엄격 관리
- **GDPR 준수**: 개인정보 처리 방침 및 사용자 동의 절차

## 성능 최적화 질문

### Q19: 데이터베이스 성능 최적화 방법은?
**A:**
- **인덱싱**: 이메일 등 자주 조회되는 컬럼에 인덱스 생성
- **커넥션 풀**: HikariCP로 데이터베이스 연결 관리
- **쿼리 최적화**: N+1 문제 해결, 페이징 처리
- **캐싱**: 자주 조회되는 데이터 Redis 캐싱

### Q20: 프론트엔드 성능 최적화는?
**A:**
- **코드 스플리팅**: 라우트별 번들 분리로 초기 로딩 최적화
- **레이지 로딩**: 필요한 시점에 컴포넌트 로드
- **이미지 최적화**: WebP 형식, 적절한 크기 조정
- **CDN 활용**: 정적 리소스 전송 최적화

---

*이 가이드는 FitMate 프로젝트의 회원가입/온보딩 시스템에 대한 주요 면접 질문과 답변을 정리한 문서입니다.*